from sqlmodel import Session, select
from app.database.config import engine, create_tables
from app.models.comment import CommentData
from app.models.blogpost import BlogPostData
from datetime import date


# create a new comment and return the comment ID generated by the database
def new_comment(date: date, content: str, post_id: int, comment_genuinity: int) -> int:
    comment = CommentData(date=date, content=content, post_id=post_id, comment_genuinity=comment_genuinity)

    with Session(engine) as session:
        session.add(comment)
        session.commit()
        session.refresh(comment)

    return comment.id


# read all comments associated with a particular post ID
def read_comments(
    post_id: int, offset: int = None, limit: int = None
) -> list[CommentData]:
    with Session(engine) as session:
        statement = (
            select(CommentData)
            .where(CommentData.post_id == post_id)
            .offset(offset)
            .limit(limit)
        )
        result = session.exec(statement)
        return result.all()


# read a comment by its own ID
def read_comment(comment_id: int) -> CommentData:
    with Session(engine) as session:
        return session.get(CommentData, comment_id)


# delete a comment
def delete_comment_db(comment_id: int) -> str:
    with Session(engine) as session:
        comment = session.get(CommentData, comment_id)
        if not comment:
            return None
        session.delete(comment)
        session.commit()
    return f"Comment {comment_id} has been permanently deleted."


# to run if we need to create the "commentdata" table - for comments
if __name__ == "__main__":
    create_tables()
